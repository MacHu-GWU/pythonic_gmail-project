# -*- coding: utf-8 -*-

"""
Base model implementation for Gmail.

This module provides the foundational data models for the Gmail API client,
implementing common patterns for representing and interacting with Gmail.
The models follow three key design patterns:

1. **Raw Data Storage Pattern**:

All models store the original API response data in a `_data` attribute, treating the
API response schema as potentially unstable. Properties provide a stable interface
for accessing the underlying data, making the code more resilient to API changes.

2. **Property-Based Access Pattern**:

All attributes are exposed through properties rather than direct instance attributes.
This approach allows for lazy loading, data validation, and type conversion while
maintaining a clean public interface.

3. **Core Data Extraction Pattern**:

Each model implements a `core_data` property that returns a standardized, minimal
representation of the object. This provides a consistent way to access essential
information across different model types.

These models are designed to be instantiated by the API client methods, not directly
by users of the library. They provide a Pythonic interface to the JSON data returned
by the native boto3 AWS Lambda API.

This file is automatically generated from
``googleapiclient-stubs/_apis/gmail/v1/schemas.pyi``
"""

import typing as T
import dataclasses
from functools import cached_property

from func_args.api import T_KWARGS, REQ, BaseFrozenModel

if T.TYPE_CHECKING:  # pragma: no cover
    from googleapiclient._apis.gmail.v1 import schemas


@dataclasses.dataclass(frozen=True)
class Base(BaseFrozenModel):
    _data: dict[str, T.Any] = dataclasses.field(default=REQ)

    @property
    def core_data(self) -> T_KWARGS:
        raise NotImplementedError


@dataclasses.dataclass(frozen=True)
class Message(Base):
    _data: "schemas.Message" = dataclasses.field(default=REQ)

    @cached_property
    def historyId(self):
        return self._data["historyId"]

    @cached_property
    def id(self):
        return self._data["id"]

    @cached_property
    def internalDate(self):
        return self._data["internalDate"]

    @cached_property
    def labelIds(self):
        return self._data["labelIds"]

    @cached_property
    def payload(self):
        return MessagePart(_data=self._data["payload"])

    @cached_property
    def raw(self):
        return self._data["raw"]

    @cached_property
    def sizeEstimate(self):
        return self._data["sizeEstimate"]

    @cached_property
    def snippet(self):
        return self._data["snippet"]

    @cached_property
    def threadId(self):
        return self._data["threadId"]


@dataclasses.dataclass(frozen=True)
class MessagePart(Base):
    _data: "schemas.MessagePart" = dataclasses.field(default=REQ)

    @cached_property
    def body(self):
        return MessagePartBody(_data=self._data["body"])

    @cached_property
    def filename(self):
        return self._data["filename"]

    @cached_property
    def headers(self):
        return [MessagePartHeader(_data=dct) for dct in self._data["headers"]]

    @cached_property
    def mimeType(self):
        return self._data["mimeType"]

    @cached_property
    def partId(self):
        return self._data["partId"]

    @cached_property
    def parts(self):
        return [MessagePart(_data=dct) for dct in self._data["parts"]]


@dataclasses.dataclass(frozen=True)
class MessagePartBody(Base):
    _data: "schemas.MessagePartBody" = dataclasses.field(default=REQ)

    @cached_property
    def attachmentId(self):
        return self._data["attachmentId"]

    @cached_property
    def data(self):
        return self._data["data"]

    @cached_property
    def size(self):
        return self._data["size"]


@dataclasses.dataclass(frozen=True)
class MessagePartHeader(Base):
    _data: "schemas.MessagePartHeader" = dataclasses.field(default=REQ)

    @cached_property
    def name(self):
        return self._data["name"]

    @cached_property
    def value(self):
        return self._data["value"]
